leetcode树
===
1、平衡二叉树的判断（110 easy）
---
常有的思路是自顶向下递归判断。解法略去啦。但由于是自顶向下，很多结点的高度会重复计算，时间复杂度较高。<br>
* 自底向上的解法
即自底向上判断，当某棵树的子树不是平衡二叉树时直接返回-1；
```
public boolean isBalanced(TreeNode root) {
        return recur(root) != -1;
    }

    private int recur(TreeNode root) {
        if (root == null) return 0;
        int left = recur(root.left);
        if(left == -1) return -1;
        int right = recur(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
  ```
2、路径总和（437 medium）
---
给定一个二叉树，它的每个结点都存放着一个整数值。<br>
找出路径和等于给定数值的路径总数。<br>
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>
示例：root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 <br>
返回 3。和等于 8 的路径有:<br>
1.  5 -> 3 <br>
2.  5 -> 2 -> 1 <br>
3.  -3 -> 11 <br>

* 双递归法
自己对递归的理解和应用不是很得心应手，但这道题用双递归的思路来理解是最容易的。<br>
递归子问题有三个，分成两类。一类与父问题处理逻辑完全相同（即pathSum(root.left,sum)和pathSum(root.right,sum)）。另一类与父问题处理逻辑不同，需要独立为另一个递归函数rootPathSum。<br>
```
    public int pathSum(TreeNode root, int sum) {
        if(root == null)
            return 0;
        int res = rootPathSum(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum); 
        return res;
    }
    public int rootPathSum(TreeNode root,int sum)
    {
        int res = 0;
        if(root == null)
            return res;
        if(root.val == sum)
            res = 1;
        res += rootPathSum(root.left,sum-root.val);
        res += rootPathSum(root.right,sum-root.val);
        return res;
    }
```
* 前缀和法
思想：前缀和就是从根结点到当前结点的路径和。用hashmap记录从根节点到当前结点的路径上共有多少个结点的前缀和为key。即key表示前缀和的值，value表示结点的个数。<br>
主要思想即如果结点A的前缀和为currsum，结点B的前缀和为currsum-sub，那么从B到A的路径长度就是sub。<br>
由于递归函数是从下向上返回的，那么递归遍历到结点A时，hashmap中一定存储着从根节点到结点A的路径上不同前缀和的值和对应的结点个数。因此只需要在hashmap中查找前缀和值为currsum-sub（currsum是
A结点的前缀和，sub是题目给出的路径长度）的结点的个数，即为以A结点为尾，路径长度为sub的路径个数。<br>
这种解法非常容易错的是，在递归子层结束，返回当前层时，需要消除当前层的影响（恢复原来状态）。<br>
```
    public int pathSum(TreeNode root, int sum) {
        HashMap<Integer,Integer> prefix = new HashMap<>();
        prefix.put(0,1);
        return getSum(root,prefix,0,sum);
    }
    public int getSum(TreeNode root,HashMap<Integer,Integer> prefix,int currsum,int sub)
    {
        //递归出口
        if(root == null)
            return 0;
        //当前层
        currsum += root.val;
        int res = prefix.getOrDefault(currsum-sub, 0);
        prefix.put(currsum,prefix.getOrDefault(currsum,0)+1);
        //子层
        res += getSum(root.left, prefix, currsum, sub);
        res += getSum(root.right, prefix, currsum, sub);
        //返回当前层时恢复状态
        prefix.put(currsum,prefix.get(currsum)-1);

        return res;
    }
```

  
  

