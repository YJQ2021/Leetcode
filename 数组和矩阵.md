leetcode数组和矩阵
===
1、移动零（283 easy）
---
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>
* 自己的解法<br>

边扫描边记录0的个数num，将非零元素向前移动num个位置。最后num个位置全部用0填充。<br>
```
      public void moveZeroes(int[] nums) {
        int num =0;
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]==0)
                num++;
            else
                nums[i-num]=nums[i];
        }
        int i=nums.length-1;
        while(num>0)
        {
            nums[i]=0;
            i--;
            num--;
        }
    }
```
* 官方解法<br>

两个指针，这种思路以后还会再用到，要掌握啦<br>
```
  public void moveZeroes(int[] nums) {
        int i=0;int j=0;
        while(j<nums.length)
        {
            if(nums[j]!=0)
            {    swap(nums,i,j);
                 i++;}
            j++;
        }
    }
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
```
2、重塑矩阵（566 easy)
给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。<br>
重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。<br>
```
      for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums[0].length; j++) {
                res[count / c][count % c] = nums[i][j];
                count++;
            }
        }
```
取余和取模的写法要掌握。<br>
3、搜索二维矩阵（240 medium）
---
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>
每行的元素从左到右升序排列。<br>
每列的元素从上到下升序排列。<br>
* 自己的解法<br>

先从左向右搜索可能存在的列，然后在搜索每一列。<br>
效率很低哇。。最坏时间复杂度有O(n方)<br>
```
    public boolean searchMatrix(int[][] matrix, int target) {
        int column = matrix[0].length;
        for(int i=0;i<matrix.length;i++)
        {
            for(int j=0;j<column;j++)
            {
                if(matrix[i][j]>target)
                    column = j;
                if(matrix[i][j]==target)
                    return true;
            }
        }
        return false;
    }
```
* 更好的解法<br>

即从第一行最后一个元素开始搜索，如何target大于当前元素，行数加一。如果target小于当前元素，列数减一。<br>
主要利用了行数越大元素越大，列数越小元素越大的特点。<br>
```
     public boolean searchMatrix(int[][] matrix, int target) {
        int row=0;
        int column=matrix[0].length-1;
        while(row<matrix.length && column>=0)
        {
            if(matrix[row][column]==target)
                return true;
            else if(matrix[row][column]>target)
                column--;
            else if(matrix[row][column]<target)
                row++;
        }
        return false;
    }
```
* 二分搜索<br>

该方法利用了行和列都是有序的，可以二分搜索。以对角线元素为搜索起点，先二分搜索该行，然后二分搜索该列。<br>
```
    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) {
        int lo = start;
        int hi = vertical ? matrix[0].length-1 : matrix.length-1;

        while (hi >= lo) {
            int mid = (lo + hi)/2;
            if (vertical) { // searching a column
                if (matrix[start][mid] < target) {
                    lo = mid + 1;
                } else if (matrix[start][mid] > target) {
                    hi = mid - 1;
                } else {
                    return true;
                }
            } else { // searching a row
                if (matrix[mid][start] < target) {
                    lo = mid + 1;
                } else if (matrix[mid][start] > target) {
                    hi = mid - 1;
                } else {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean searchMatrix(int[][] matrix, int target) {
        // an empty matrix obviously does not contain `target`
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        // iterate over matrix diagonals
        int shorterDim = Math.min(matrix.length, matrix[0].length);
        for (int i = 0; i < shorterDim; i++) {
            boolean verticalFound = binarySearch(matrix, target, i, true);
            boolean horizontalFound = binarySearch(matrix, target, i, false);
            if (verticalFound || horizontalFound) {
                return true;
            }
        }
        
        return false; 
    }
```
5、合并k个升序链表（23 hard）
----
本题是378题的基础版<br>
给你一个链表数组，每个链表都已经按升序排列。<br>
请你将所有链表合并到一个升序链表中，返回合并后的链表。<br>
* 逐个合并<br>

知道如何归并两个有序链表，那么归并k个升序链表可以两两归并。<br>
```
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode res = null;
        for(int i=0;i<lists.length;i++)
            res = mergeTwo(res,lists[i]);
        return res;
    }
    //合并两个有序链表的解法要熟练掌握，这里设一个头结点head，最后返回head.next较简便
    public ListNode mergeTwo(ListNode a,ListNode b)
    {
        ListNode head = new ListNode();
        ListNode pa = a;
        ListNode rear = head;
        ListNode pb = b;
        while(pa!=null && pb!=null)
        {
            if(pa.val<=pb.val)
            {    rear.next=pa;
                 pa=pa.next;}
            else
            {    rear.next=pb;
                 pb=pb.next;}
            rear=rear.next;
        }
        if(pa!=null)
            rear.next=pa;
        else
            rear.next=pb;
        return head.next;
    }
    
}
```
* 分治合并<br>
采用分治的方法进行合并，时间复杂度达到了100%。<br>
```
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists,0,lists.length-1);
    }
    public ListNode merge(ListNode[] lists,int l,int h)
    {
        if(l==h)
            return lists[l];
        if(l>h)
            return null;
        int mid = (l+h)/2;
        ListNode a = merge(lists,l,mid);
        ListNode b = merge(lists,mid+1,h);
        return mergeTwo(a,b);
    }
    public ListNode mergeTwo(ListNode a,ListNode b)
    {
        ListNode head = new ListNode();
        ListNode pa = a;
        ListNode rear = head;
        ListNode pb = b;
        while(pa!=null && pb!=null)
        {
            if(pa.val<=pb.val)
            {    rear.next=pa;
                 pa=pa.next;}
            else
            {    rear.next=pb;
                 pb=pb.next;}
            rear=rear.next;
        }
        if(pa!=null)
            rear.next=pa;
        else
            rear.next=pb;
        return head.next;
    }
```
* 优先级队列<br>

先了解下优先级队列的基本用法<br>
优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序，常用的方法和Queue相同。可以放基本类型的包装类，默认按照升序排列。也可以放自定义类。<br>
自定义比较器:<br>
```
//矩形类
class Node{
    public Node(int chang,int kuan)
    {
        this.chang=chang;
        this.kuan=kuan;
    }
    int chang;
    int kuan;
}

public class Test {
　　//自定义比较类，先比较长，长升序排列，若长相等再比较宽，宽降序
    static Comparator<Node> cNode=new Comparator<Node>() {
        public int compare(Node o1, Node o2) {
            if(o1.chang!=o2.chang)
                return o1.chang-o2.chang;
            else
                return o2.kuan-o1.kuan;
        }
        
    };
    public static void main(String[] args) {
        Queue<Node> q=new PriorityQueue<>(cNode);
        Node n1=new Node(1, 2);
        Node n2=new Node(2, 5);
        Node n3=new Node(2, 3);
        Node n4=new Node(1, 2);
        q.add(n1);
        q.add(n2);
        q.add(n3);
        Node n;
        while(!q.isEmpty())
        {
            n=q.poll();
            System.out.println("长: "+n.chang+" 宽：" +n.kuan);
        }
　　　　　/**
　　　　　　* 输出结果
　　　　　　* 长: 1 宽：2
　　　　　　* 长: 2 宽：5
　　　　　　* 长: 2 宽：3
　　　　　　*/
    }
 }
```
本题将数组中所有结点放入优先级队列，然后再出队串联成新链表返回<br>
```
public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> q = new PriorityQueue<>((x,y)->x.val-y.val);
        for(ListNode node : lists){
            if(node!=null){
                q.add(node);
            }
        }
        ListNode head = new ListNode(0);
        ListNode tail = head;
        while(!q.isEmpty()){
            tail.next = q.poll();
            tail = tail.next;
            if (tail.next != null){
                q.add(tail.next);
            }
        }
        return head.next;
    }
```
4、有序矩阵中第k小的元素（378 medium）
---
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。<br>

5、错误的集合（645 easy）
---
集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合丢失了一个数字并且有一个数字重复。<br>
给定一个数组 nums 代表了集合 S 发生错误后的结果。<br>
请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。<br>
* 自己的解法<br>

额外开辟大小为n的boolean数组，用数组的值为true或者false来判断某一整数出现了两次或者没有出现。<br>
```
    public int[] findErrorNums(int[] nums) {
        boolean[] a = new boolean[nums.length];
        int[] res = new int[2]; 
        int j=0;
        for(int num:nums)
        {    
            if(a[num-1])
            {    res[j]=num;
                 j++;}
            a[num-1]=true;
        }
        for(int i=0;i<nums.length;i++)
        {
            if(!a[i])  
                res[j]=i+1;
        }
        return res;
    }
 ```
 * 改进版本<br>
 
 不用额外开辟数组，用nums数组值的正负来标记某一元素是否出现过两次或者没有出现。<br>
 ```
    public int[] findErrorNums(int[] nums) {
        int dup = -1, missing = 1;
        for (int n: nums) {
            if (nums[Math.abs(n) - 1] < 0)
                dup = Math.abs(n);
            else
                nums[Math.abs(n) - 1] *= -1;
        }
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > 0)
                missing = i + 1;
        }
        return new int[]{dup, missing};
    }
 ```
 * 位运算<br>
 
 
 


