Leetcode链表
============

第一次接触力扣，选择从较简单的链表开始。刷了十道较经典的题目，总结如下啦!<br>

1、合并两个有序链表 (160 easy)
------------------
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 <br>
示例：<br>
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4] <br>
<br>
思路：两个链表各设置一个工作指针。比较两个指针所指结点值，值较小者结点加入返回链表，并向前移动该指针。循环比较直到有一个指针移动到链表尾。将两个链表中非空的那一个的剩余结点加入返回链表。<br>
<br>
代码实现：<br>
* 迭代法
```
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //判断链表是否为空
        if(l1==null)  return l2;
        if(l2==null)  return l1;
        //p和q是链表1和链表2的工作指针，head是要返回链表的头结点
        //采用尾插法插入新结点，所以设置尾指针rear
        ListNode p = l1;
        ListNode q = l2;
        ListNode head=null;
        ListNode rear = head;
        //两个链表都不为空时，继续比较
        while(p!=null && q!=null)
        {
            if(p.val<=q.val)
            {
                //插入第一个结点和其余结点的操作不同，所以需要判断
                if(head==null)
                    head = rear = p;
                else
                {
                    rear.next=p;
                    rear=p;
                }
                p = p.next;
            }
            else
            {
                if(head==null)
                    head = rear = q;
                else
                {
                    rear.next=q;
                    rear=q;
                }
                q = q.next;
            }
        }
        //非空的链表加入返回表末尾
        if(p!=null)
            rear.next = p;
        if(q!=null) 
            rear.next = q;
        return head;
    }
```
迭代法中的官方解法: <br>
官方解法和自己的解法是一个思路，但是代码行数少了不止一点。。。<br>
（1）prevhead相当于头结点，最后返回的是prev.next，解决了自己代码中插入第一个结点与其他结点操作不同的问题
（2） prev.next = l1 == null ? l2 : l1 三目运算符
```
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);

        ListNode prev = prehead;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
```

* 递归法
递归关键抓住递归出口和子问题<br>
```
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
```


