leetcode贪心算法
===
1、分发饼干（455 easy）
---
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。<br>
* 题解<br>
本题的贪心思想和代码实现都比较容易理解
```java
public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i=0,j=0;
        int res=0;
        while(i<g.length && j<s.length)
        {
            if(g[i]<=s[j])
            {
                i++;
                j++;
                res++;
            }
            else
                j++;
        }
        return res;
    }
```
需要掌握的是证明贪心思想是最优解的思路：即如果不给当前胃口最小的孩子分配满足胃口的最小饼干，而是分配比最小饼干更大的饼干，得到的解不会优于贪心思想的解。证明如下：<br>
假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m < n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。<br>
2、无重叠区间（435 medium）
---
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。<br>
注意:<br>
可以认为区间的终点总是大于它的起点。<br>
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>
* 自己的解法（贪心法）<br>

将数组按照第一个元素递增排序，从前向后遍历数组。如果当前数组的第一个元素小于上一个数组的最后一个元素end，那么一定会发生重合，这时候要去除重合数组中的一个。根据贪心法的思想，应该去除的是右区间较小的那个数组，更新end，并且自增res。<br>
这道题最开始卡的地方在于去除数组，由于本题只用返回需要去除数组的数量，所以没有必要真正去除数组，只需要逻辑去除。也就是在逻辑上更新end值，<br>
```java
 public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length==0 || intervals.length==1)
            return 0;
        Arrays.sort(intervals,new Comparator<int[]>() {
                                @Override
                                public int compare(int[] o1, int[] o2) {
                                if (o1[0]==o2[0]) return o1[1]-o2[1];
                                return o1[0]-o2[0];
                                }
                            });
        
        int res=0;
        int end = intervals[0][1];
        for(int i=1;i<intervals.length;i++)
        {
            if(intervals[i][0]<end)
            {    end = Math.min(end,intervals[i][1]);
                 res++;}
            else
                end = intervals[i][1];
        }
        return res;
    }
```
* 贪心法（按尾部排序）<br>

找到需要移除区间的最小数量，就是找不重叠区间的最大数量。<br>
思考下如何能够使不重叠区间的数量最大，即如果能保证每一个加入的区间都和前面的区间不重合，且右端点值最小，那么不重叠区间的数量会达到最大。那么可以按照右区间端点从小到大的顺序对数组进行排序，再遍历数组，如果当前数组（当前数组一定是右端点值最小的数组）与之前的数组不重合，那么当前数组加入，cnt自增。最后要移除区间的数量就是区间的总数减去最大数量。<br>
```java
public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length==0 || intervals.length==1)
            return 0;
        Arrays.sort(intervals,new Comparator<int[]>() {
                                @Override
                                public int compare(int[] o1, int[] o2) {
                                return o1[1]-o2[1];
                                }
                            });
        int end = intervals[0][1];
        int cnt = 1;
        for(int i=1;i<intervals.length;i++)
        {
            if(intervals[i][0]<end)
                continue;
            end = intervals[i][1];
            cnt++;
        }
        return intervals.length-cnt;
    }
```
要注意写数组排序的函数时，为了防止减法溢出，最好采用如下写法：<br>
```java
new Comparator<int[]>() {
                                public int compare(int[] o1, int[] o2) {
                                    return (o1[1] < o2[1]) ? -1 : ((o1[1] == o2[1]) ? 0 : 1);
                            }}
```


