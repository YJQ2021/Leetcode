算法基础
===
1、动态规划题目特点
===
* 计数<br>
有多少种方式走到右下角<br>
有多少种方法选出k个数使得和是sum<br>
* 求最大最小值<br>
从左上角走到右下角路径的最大数字和<br>
最长上升子序列长度<br>
* 求存在性<br>
取石子游戏，先手是否必胜<br>
能不能选出k个数使得和是sum<br>
<br>
递归解法的问题：做了很多重复计算，效率低下。动态规划是将计算结果保存下来，并改变计算顺序。弥补了递归解法的不足。<br>

3、解题步骤
===
* 确定状态<br>

状态在动态规划中的作用属于定海神针。简单的说，解动态规划时需要开一个数组（即状态），数组的每个元素f[i]或者f[i][j]代表什么。<br>
确定状态需要两个意识：最后一步、子问题。最后一步即最优策略中的最后一步决策；子问题是去掉最后一步得到的更小规模的问题；根据子问题可以确定状态。<br>

* 转移方程<br>

f(k)=最少用多少枚硬币可以拼出k<br>
f(k)=min{f(k-2)+1,f(k-5)+1,f(k-7)+1}<br>

* 初始条件和边界情况<br>

初始条件就是用转移方程看不出来的，但是我又需要它的定义。如f(0)用转移方程算出来应该是正无穷，但是f(0)=0，所以需要手动显式定义。<br>
边界情况就是不要数组越界。<br>

* 计算顺序<br>

确定原则：当需要计算等式左边时，等式右边已经得到。<br>
大多数是从小到大，二维就是从上到下、从左到右。<br>



2、例题
===
（1）lintcode 669 换硬币问题
--
给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.<br>

输入：<br>
[2,5,7]<br>
27<br>

### 解题步骤
* 确定状态：最后一步、子问题<br>
最后一步：虽然不知道最优策略是什么，但是最优策略肯定是k枚硬币a1,a2.....ak，面值加起来是27.所以一定有最后一枚硬币ak。除掉这枚硬币，前面硬币的面值加起来就是27-ak。<br>
子问题：拼出27-ak的硬币数一定最小。<br>
确定状态：f(k)=最少用多少枚硬币可以拼出k<br>
在本输入中：f(27)=min{f(27-2)+1,f(27-5)+1,f(27-7)+1}<br>
* 转移方程<br>
f(k)=最少用多少枚硬币可以拼出k<br>
f(k)=min{f(k-2)+1,f(k-5)+1,f(k-7)+1}<br>
* 初始条件和边界情况<br>
初始条件：f(0)=0<br>
边界情况：如果不能拼出Y，就定义f(Y)=正无穷。如f(-1)=f(-2)=...=正无穷<br>
* 计算顺序<br>
计算f(1)、f(2)、f(3).....f(27)。<br>

### 代码
```java
 public int coinChange(int[] coins, int amount) {
        int[] f = new int[amount+1];
        //初始化
        f[0]=0;
        //最少用多少枚硬币拼出amount元
        for(int i=1;i<=amount;i++)
        {
            f[i] = Integer.MAX_VALUE;
            //最后一枚可能是coins中的某个
            for(int a:coins)
            {
                if(i-a >= 0 && f[i-a]!=Integer.MAX_VALUE)
                   f[i] = Math.min(f[i],f[i-a]+1);
            }
        }
        if(f[amount]==Integer.MAX_VALUE)
            return -1;
        return f[amount];   
    }
```
（2）lintcode 114 路径总数
---





